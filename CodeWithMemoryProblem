#include <iostream>

void memoryLeakExample() {
    std::cout << "\n--- Memory Leak Example ---\n";
    int* ptr = new int(10);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    // Memory Leak: forgot to delete ptr
    // delete ptr;  // This line is missing intentionally to show the leak
    // Problem: If this function is called repeatedly, memory usage will grow
}

void danglingPointerExample() {
    std::cout << "\n--- Dangling Pointer Example ---\n";
    int* ptr = new int(42);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted." << std::endl;

    // Dangling Pointer: ptr still points to freed memory
    // Accessing it now causes undefined behavior
    *ptr = 100;  // UNDEFINED BEHAVIOR
    std::cout << "Modified dangling pointer value: " << *ptr << std::endl;
}

void doubleDeletionExample() {
    std::cout << "\n--- Double Deletion Example ---\n";
    int* ptr = new int(5);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted once." << std::endl;

    delete ptr;  // UNDEFINED BEHAVIOR: double delete
    std::cout << "Pointer deleted twice!" << std::endl;
}

int main() {
    memoryLeakExample();
    // Comment out one by one to observe errors
    danglingPointerExample();
    doubleDeletionExample();

    std::cout << "\nProgram finished (may crash or behave unexpectedly due to undefined behavior)." << std::endl;
    return 0;
}







#include <iostream>
#include <new>       // For std::bad_alloc
using namespace std;

void memoryCorruptionExample() {
    cout << "\n--- Memory Corruption Example ---\n";
    int* arr = new int[3];  // Allocating space for 3 integers: arr[0], arr[1], arr[2]

    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;

    // Memory Corruption: writing out of bounds
    arr[3] = 99;  // Undefined behavior: arr[3] is out of bounds

    cout << "Value beyond bounds arr[3]: " << arr[3] << " (this is invalid access!)" << endl;

    delete[] arr;
}

void mismatchedAllocationExample() {
    cout << "\n--- Mismatched Allocation/Deallocation Example ---\n";

    int* arr = new int[5];  // Allocated with new[]
    arr[0] = 42;

    // Wrong deallocation
    delete arr;  // Should be delete[] arr

    // Problem: May lead to resource leaks or runtime issues
    cout << "Mismatched delete executed (delete used instead of delete[])." << endl;
}

void allocationFailureExample() {
    cout << "\n--- Allocation Failure Handling Example ---\n";

    try {
        // Try allocating a huge block of memory (may fail)
        int* ptr = new int[1000000000];  // Depends on system; may throw bad_alloc

        cout << "Memory allocation succeeded (unexpected on low-memory systems)." << endl;
        delete[] ptr;
    }
    catch (const bad_alloc& e) {
        // Proper handling of allocation failure
        cerr << "Memory allocation failed: " << e.what() << endl;
    }

    // Optional: Using nothrow to avoid exceptions
    int* ptr2 = new(nothrow) int[1000000000];
    if (!ptr2) {
        cerr << "Memory allocation failed using nothrow." << endl;
    }
    else {
        cout << "Memory allocation with nothrow succeeded." << endl;
        delete[] ptr2;
    }
}

int main() {
    memoryCorruptionExample();       // Causes memory corruption
    mismatchedAllocationExample();   // Wrong deallocation method
    allocationFailureExample();      // Demonstrates exception and nothrow handling

    cout << "\nProgram finished (some parts may crash or behave unpredictably due to memory errors).\n";
    return 0;
}








