#include <iostream>

void memoryLeakExample() {
    std::cout << "\n--- Memory Leak Example ---\n";
    int* ptr = new int(10);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    // Memory Leak: forgot to delete ptr
    // delete ptr;  // This line is missing intentionally to show the leak
    // Problem: If this function is called repeatedly, memory usage will grow
}

void danglingPointerExample() {
    std::cout << "\n--- Dangling Pointer Example ---\n";
    int* ptr = new int(42);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted." << std::endl;

    // Dangling Pointer: ptr still points to freed memory
    // Accessing it now causes undefined behavior
    *ptr = 100;  // UNDEFINED BEHAVIOR
    std::cout << "Modified dangling pointer value: " << *ptr << std::endl;
}

void doubleDeletionExample() {
    std::cout << "\n--- Double Deletion Example ---\n";
    int* ptr = new int(5);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted once." << std::endl;

    delete ptr;  // UNDEFINED BEHAVIOR: double delete
    std::cout << "Pointer deleted twice!" << std::endl;
}

int main() {
    memoryLeakExample();
    // Comment out one by one to observe errors
    danglingPointerExample();
    doubleDeletionExample();

    std::cout << "\nProgram finished (may crash or behave unexpectedly due to undefined behavior)." << std::endl;
    return 0;
}







#include <iostream>
#include <new>       // For std::bad_alloc
using namespace std;

void memoryCorruptionExample() {
    cout << "\n--- Memory Corruption Example ---\n";
    int* arr = new int[3];  // Allocating space for 3 integers: arr[0], arr[1], arr[2]

    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;

    // Memory Corruption: writing out of bounds
    arr[3] = 99;  // Undefined behavior: arr[3] is out of bounds

    cout << "Value beyond bounds arr[3]: " << arr[3] << " (this is invalid access!)" << endl;

    delete[] arr;
}

void mismatchedAllocationExample() {
    cout << "\n--- Mismatched Allocation/Deallocation Example ---\n";

    int* arr = new int[5];  // Allocated with new[]
    arr[0] = 42;

    // Wrong deallocation
    delete arr;  // Should be delete[] arr

    // Problem: May lead to resource leaks or runtime issues
    cout << "Mismatched delete executed (delete used instead of delete[])." << endl;
}

void allocationFailureExample() {
    cout << "\n--- Allocation Failure Handling Example ---\n";

    try {
        // Try allocating a huge block of memory (may fail)
        int* ptr = new int[1000000000];  // Depends on system; may throw bad_alloc

        cout << "Memory allocation succeeded (unexpected on low-memory systems)." << endl;
        delete[] ptr;
    }
    catch (const bad_alloc& e) {
        // Proper handling of allocation failure
        cerr << "Memory allocation failed: " << e.what() << endl;
    }

    // Optional: Using nothrow to avoid exceptions
    int* ptr2 = new(nothrow) int[1000000000];
    if (!ptr2) {
        cerr << "Memory allocation failed using nothrow." << endl;
    }
    else {
        cout << "Memory allocation with nothrow succeeded." << endl;
        delete[] ptr2;
    }
}

int main() {
    memoryCorruptionExample();       // Causes memory corruption
    mismatchedAllocationExample();   // Wrong deallocation method
    allocationFailureExample();      // Demonstrates exception and nothrow handling

    cout << "\nProgram finished (some parts may crash or behave unpredictably due to memory errors).\n";
    return 0;
}








#include <iostream>
#include <stdexcept>
using namespace std;

// === 7. Hidden Ownership Problem ===
void process(int* data) {
    cout << "\n--- Hidden Ownership Issue ---\n";
    // Do something with data
    cout << "Processing data: " << *data << endl;

    // But: Who should delete data?
    // If we delete it here, caller must NOT delete it
    // If we don't delete, caller must remember to delete it

    // delete data;  // Uncommenting this may cause double delete if caller also deletes it
}

void hiddenOwnershipExample() {
    int* data = new int(42);
    process(data);

    // Unclear ownership: should we delete here or was it already deleted in process()?
    delete data;  // Double delete if process() already deleted it
}


// === 8. Forgetting to Delete in All Code Paths ===
void forgettingToDeleteExample(bool triggerEarlyReturn, bool triggerException) {
    cout << "\n--- Forgetting to Delete in All Code Paths ---\n";
    int* ptr = new int(7);
    cout << "Allocated: " << *ptr << endl;

    if (triggerEarlyReturn) {
        cout << "Early return — memory leak!\n";
        return;  // ❌ Leak: delete is never called
    }

    if (triggerException) {
        cout << "Throwing exception — memory leak!\n";
        throw runtime_error("Exception occurred");  // ❌ Leak: delete is skipped
    }

    delete ptr;  // ✅ Only happens in normal flow
    cout << "Deleted successfully.\n";
}

int main() {
    // Demonstrate Hidden Ownership
    hiddenOwnershipExample();

    // Demonstrate forgetting to delete on early return
    forgettingToDeleteExample(true, false);

    // Demonstrate forgetting to delete on exception
    try {
        forgettingToDeleteExample(false, true);
    } catch (const exception& ex) {
        cout << "Caught exception: " << ex.what() << endl;
    }

    cout << "\nProgram finished (some paths leak memory).\n";
    return 0;
}





