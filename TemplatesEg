#include <iostream>
using namespace std;
template <typename T>
T maxm(T a, T b) {
	return (a > b) ? a : b;
}

template <typename T>
T minm(T a, T b) {
	return (a < b) ? a : b;
}

int main() {
	cout << maxm(5, 6) << endl;
	cout << maxm((double)5, 6.6) << endl;
	cout << maxm<double>(5, 6.6) << endl;
}
//Output:
//6






#include <iostream>
using namespace std;
template <typename T>
T maxm(T a, T b) {
	return (a > b) ? a : b;
}

template <typename T, typename U>
T minm(T a, U b) {
	return (a < b) ? a : b;
}


template <typename T, typename U, typename R>
R eqChk(T a, U b) {
	return a==b;
}

int main() {
	cout << maxm(5, 6) << endl;
	cout << maxm((double)5, 6.6) << endl;
	cout << maxm<double>(5, 6.6) << endl;


	cout << minm<int, double>(5.89, 6) << endl;

	bool b = eqChk<int, int, bool>(4, 4);
	cout << b;
}
//Output:
//6



#include <iostream>
using namespace std;
template <class T>
class mypair {
    T a, b;
public:
    mypair(T first, T second)
    {
        a = first; b = second;
    }
    T getmax() {
        T retval;
        retval = a > b ? a : b;
        return retval;
    }
};
int main() {
    mypair <int> myobject(100, 75);
    cout << myobject.getmax();
    return 0;
}





#include<iostream>
using namespace std;
template<class T, class U = char>
class A {
    public:
	T x;
	U y;
	A() { cout << "Constructor Called" << endl; }
};
int main() {
	A<char> a;  // This will call A<char, char> 
	A<int, double> b; // This will call A<int, double> 
  
	return 0;
}







#include <iostream>
#include <array>
constexpr int square(int n) { //constexpr function
    return n * n;
} 
// constexpr constructor & method
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
    constexpr int getX() const { return x; }
};
int main() {
    // constexpr with variables
    constexpr int maxValue = 100;       // compile-time constant
    constexpr double pi = 3.14159;      // compile-time constant
    // int runtimeValue = 50;
    // constexpr int invalidConstexpr = runtimeValue; // ERROR: not known at compile time

    // constexpr with functions
    constexpr int ctSquare = square(5); // compile-time evaluation
    int num = 7;
    int rtSquare = square(num);         // runtime evaluation

    // constexpr constructors and objects
    constexpr Point p1(3, 4); // compile-time object
    Point p2(5, 6);           // runtime object

    // constexpr vs const
    const int constVar = 10;        // runtime constant (may be optimized)
    constexpr int constExprVar = 20; // compile-time constant guaranteed

    // Using constexpr in compile-time context (array size)
    std::array<int, square(4)> arr; // size = 16 at compile time

    // Output results
    std::cout << "1. Constexpr Variables: maxValue = " << maxValue << ", pi = " << pi << "\n";
    std::cout << "2️. Constexpr Functions: ctSquare (compile-time) = " << ctSquare
        << ", rtSquare (runtime) = " << rtSquare << "\n";
    std::cout << "3️. Constexpr Objects: p1.x = " << p1.getX() << ", p2.x = " << p2.getX() << "\n";
    std::cout << "4️. Const vs Constexpr: constVar = " << constVar
        << ", constExprVar = " << constExprVar << "\n";
    std::cout << "Array size using constexpr = " << arr.size() << "\n";
}







#include<iostream>
using namespace std;
template<typename T>
constexpr T PI = T(3.1415926535897932385);
int main()
{
    cout<<"PI:"<< PI<int><<endl;
    cout << "PI:" << PI<double> << endl;
    return 0;
}
//constexpr is compile time interference
//constexpr can be used as an expression elsewhere also; sealed or final keyword in c#/java




#include<iostream>
using namespace std;
template<typename T>
T PI = T(3.1415926535897932385);
template<typename T>
T area(T r) {
	return PI<T> * r * r;
}
int main()
{
	cout<<"PI:"<< PI<int><<"  area: "<<area(2)<<endl;
	cout << "PI:" << PI<double> << "  area: " << area(2.0) << endl;
	return 0;
}

















