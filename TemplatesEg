#include <iostream>
using namespace std;
template <typename T>
T maxm(T a, T b) {
	return (a > b) ? a : b;
}

template <typename T>
T minm(T a, T b) {
	return (a < b) ? a : b;
}

int main() {
	cout << maxm(5, 6) << endl;
	cout << maxm((double)5, 6.6) << endl;
	cout << maxm<double>(5, 6.6) << endl;
}
//Output:
//6






#include <iostream>
using namespace std;
template <typename T>
T maxm(T a, T b) {
	return (a > b) ? a : b;
}

template <typename T, typename U>
T minm(T a, U b) {
	return (a < b) ? a : b;
}


template <typename T, typename U, typename R>
R eqChk(T a, U b) {
	return a==b;
}

int main() {
	cout << maxm(5, 6) << endl;
	cout << maxm((double)5, 6.6) << endl;
	cout << maxm<double>(5, 6.6) << endl;


	cout << minm<int, double>(5.89, 6) << endl;

	bool b = eqChk<int, int, bool>(4, 4);
	cout << b;
}
//Output:
//6



#include <iostream>
using namespace std;
template <class T>
class mypair {
    T a, b;
public:
    mypair(T first, T second)
    {
        a = first; b = second;
    }
    T getmax() {
        T retval;
        retval = a > b ? a : b;
        return retval;
    }
};
int main() {
    mypair <int> myobject(100, 75);
    cout << myobject.getmax();
    return 0;
}





#include<iostream>
using namespace std;
template<class T, class U = char>
class A {
    public:
	T x;
	U y;
	A() { cout << "Constructor Called" << endl; }
};
int main() {
	A<char> a;  // This will call A<char, char> 
	A<int, double> b; // This will call A<int, double> 
  
	return 0;
}







#include <iostream>
#include <array>
constexpr int square(int n) { //constexpr function
    return n * n;
} 
// constexpr constructor & method
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
    constexpr int getX() const { return x; }
};
int main() {
    // constexpr with variables
    constexpr int maxValue = 100;       // compile-time constant
    constexpr double pi = 3.14159;      // compile-time constant
    // int runtimeValue = 50;
    // constexpr int invalidConstexpr = runtimeValue; // ERROR: not known at compile time

    // constexpr with functions
    constexpr int ctSquare = square(5); // compile-time evaluation
    int num = 7;
    int rtSquare = square(num);         // runtime evaluation

    // constexpr constructors and objects
    constexpr Point p1(3, 4); // compile-time object
    Point p2(5, 6);           // runtime object

    // constexpr vs const
    const int constVar = 10;        // runtime constant (may be optimized)
    constexpr int constExprVar = 20; // compile-time constant guaranteed

    // Using constexpr in compile-time context (array size)
    std::array<int, square(4)> arr; // size = 16 at compile time

    // Output results
    std::cout << "1. Constexpr Variables: maxValue = " << maxValue << ", pi = " << pi << "\n";
    std::cout << "2️. Constexpr Functions: ctSquare (compile-time) = " << ctSquare
        << ", rtSquare (runtime) = " << rtSquare << "\n";
    std::cout << "3️. Constexpr Objects: p1.x = " << p1.getX() << ", p2.x = " << p2.getX() << "\n";
    std::cout << "4️. Const vs Constexpr: constVar = " << constVar
        << ", constExprVar = " << constExprVar << "\n";
    std::cout << "Array size using constexpr = " << arr.size() << "\n";
}







#include<iostream>
using namespace std;
template<typename T>
constexpr T PI = T(3.1415926535897932385);
int main()
{
    cout<<"PI:"<< PI<int><<endl;
    cout << "PI:" << PI<double> << endl;
    return 0;
}
//constexpr is compile time interference
//constexpr can be used as an expression elsewhere also; sealed or final keyword in c#/java




#include<iostream>
using namespace std;
template<typename T>
T PI = T(3.1415926535897932385);
template<typename T>
T area(T r) {
	return PI<T> * r * r;
}
int main()
{
	cout<<"PI:"<< PI<int><<"  area: "<<area(2)<<endl;
	cout << "PI:" << PI<double> << "  area: " << area(2.0) << endl;
	return 0;
}






#include<iostream>
using namespace std;
// To handle base case of below recursive
// Variadic function Template
void print()
{
	cout << "I am empty function and "
		"I am called at last.\n";
}
// Variadic function Template that takes variable number 
//of arguments and prints all of them.
template <typename T, typename... Types>
void print(T var1, Types... var2) {
	cout << var1 << endl;
	print(var2...);
}
int main() {
	print(1, 2, 3.14, "Pass me any "
		"number of arguments",
		"I will print\n");
	return 0;
}






#include<iostream>
#include<string>
using namespace std;
template<typename T>
T adder(T v) {
    return v;
}

template<typename T, typename... Args>
T adder(T first, Args... args) {
    return first + adder(args...);
}
int main() {
    long sum = adder(1, 2, 3, 8, 7);
    cout << "sum(1, 2, 3, 8, 7) =" << sum << endl;
    string s1 = "x", s2 = "aa", s3 = "bb", s4 = "yy";
    int x=9, y=8;
    string ssum = adder(s1, s2, s3, s4 );
    cout << "string sum=" << ssum << endl;
    return 0;
}








#include <iostream>
using namespace std;
template <class T>
void fun(T a) {
	cout << "The main template fun(): " << a << endl;
}
template<>
void fun(int a) {
	cout << "Specialized Template for int type: " << a << endl;
}
int main() {
	fun<char>('a');
	fun<int>(10);
	fun<float>(10.14);
	fun(45);
}









#include <iostream>
using namespace std;
template <class T>
class Test  { 	// Data memnbers of test
public:
	Test() 	{ 		// Initialization of data members
		cout << "General template object \n";
	} 	// Other methods of Test
};
template <>
class Test <int> {
public:
	Test() 	{ 	// Initialization of data members
		cout << "Specialized template object\n";
	}
};
int main() {
	Test<int> a;
	Test<char> b;
	Test<float> c;
	return 0;
}

















