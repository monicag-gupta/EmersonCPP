#include <boost/regex.hpp>
#include <iostream>
using namespace std;
using namespace boost;

int main() {
    regex expr("(\\w+)@(\\w+).(\\w+)");
    string email = "test@example.com";
    if (regex_match(email, expr)) {
        cout << "Valid email: " << email<<" !!"<<endl;
    }
    else
        cout << "Invalid email address : " << email << endl;
}






#include <boost/scoped_ptr.hpp>
#include <iostream>
using namespace std;
class Emp {
public:
    Emp() {
        cout << "Emp constructed";
    }
    Emp(int x) {
        cout << "Emp constructed";
    }
    ~Emp() {
        cout << "Emp destructed";
    }
    string display() {
       return "I am an Emp Object";
    }
};
int main() {
    cout << "In scope:";
    {
        boost::scoped_ptr<Emp> p(new Emp());
        cout << endl << p->display() << endl;  // prints display()
        // no delete needed
    }
    cout << ":Out of Scope";
}





#include <boost/shared_ptr.hpp>
#include <iostream>
using namespace std;
class Emp {
public:
    int xx;
    Emp() {
        cout << "Emp constructed";
    }
    Emp(int x) {
        xx = x;
        cout << "Emp constructed";
    }
    ~Emp() {
        cout << "Emp destructed";
    }
    string display() {
       cout << xx;
       return " I am an Emp Object" ;
    }
};
int main() {
    cout << "In scope:";
    {
        boost::shared_ptr<Emp> p1(new Emp(20));
        boost::shared_ptr<Emp> p2 = p1; // shared ownership
        cout <<"\nP1:"<< p1->display() << "\nP2: " << p2->display() << endl;  // prints 20 20
        cout << "use_count = " << p1.use_count() << endl; // 2
    }
    cout << ":Out of Scope";
}






#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

#include <iostream>
using namespace std;
class Emp {
public:
    int xx;
    Emp() {
        cout << "Emp constructed";
    }
    Emp(int x) {
        xx = x;
        cout << "Emp constructed";
    }
    ~Emp() {
        cout << "Emp destructed";
    }
    string display() {
       cout << xx;
       return " I am an Emp Object" ;
    }
};
int main() {
    cout << "In scope:";
    {
        boost::shared_ptr<Emp> sp(new Emp(20));
        boost::weak_ptr<Emp> wp = sp; // non-owning reference
        cout <<"\nsp:"<< sp->display() << "\nwp: " << (wp.lock())->display() << endl;  // prints 20 20
        cout << "use_count = " << sp.use_count() << endl; // 1
    }
    cout << ":Out of Scope";
}










#include <iostream>
#include <boost/shared_ptr.hpp>
class B; // forward declaration
class A {
public:
    boost::shared_ptr<B> ptrB;
    ~A() { std::cout << "A destroyed\n"; }
};
class B {
public:
    boost::shared_ptr<A> ptrA;
    ~B() { std::cout << "B destroyed\n"; }
};
int main() {
    {
        boost::shared_ptr<A> a(new A());
        boost::shared_ptr<B> b(new B());
        a->ptrB = b;  // A points to B
        b->ptrA = a;  // B points to A  (Cyclic reference!)
    } // scope ends, but destructors not called
    std::cout << "End of main\n";
    return 0;
}










#include <iostream>
#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

class B; // forward declaration
class A {
public:
    boost::shared_ptr<B> ptrB;
    ~A() { std::cout << "A destroyed\n"; }
};
class B {
public:
    //boost::shared_ptr<A> ptrA;
    boost::weak_ptr<A> ptrA; // weak_ptr breaks cycle

    ~B() { std::cout << "B destroyed\n"; }
};
int main() {
    {
        boost::shared_ptr<A> a(new A());
        boost::shared_ptr<B> b(new B());
        a->ptrB = b;  // A points to B
        b->ptrA = a;  // B points to A  (Cyclic reference has been broken!)
    } // scope ends, and destructors are called
    std::cout << "End of main\n";
    return 0;
}










#include <boost/intrusive_ptr.hpp>
#include <iostream>
using namespace std;
class RefCounted {
    int refCount = 0;
public:
    friend void intrusive_ptr_add_ref(RefCounted* p) { ++p->refCount; }
    friend void intrusive_ptr_release(RefCounted* p) {
        if (--p->refCount == 0) delete p;
    }
    void hello() { cout << "Hello from RefCounted!" << endl; }
};
int main() {
    boost::intrusive_ptr<RefCounted> p(new RefCounted());
    p->hello();
}







#include <boost/make_shared.hpp>
#include <iostream>
using namespace std;
int main() {
    auto p = boost::make_shared<int>(42);
    cout << *p << endl;
}






#include <boost/filesystem.hpp>
#include <iostream>
namespace fs = boost::filesystem;
int main() {
    fs::path p("data.txt");
    if (fs::exists(p)) {
        std::cout << p << " exists\n";
        if (fs::is_regular_file(p))
            std::cout << "File size: " << fs::file_size(p) << " bytes\n";
        else if (fs::is_directory(p))
            std::cout << p << " is a directory\n";
    }
    else {
        std::cout << p << " does not exist\n";
    }
}




In Project folder create:
data.txt:
Hello, World!





#include <boost/filesystem.hpp>
#include <iostream>
namespace fs = boost::filesystem;
int main() {
    fs::path p("data.txt");
    if (fs::exists(p)) {
        std::cout << p << " exists\n";
        if (fs::is_regular_file(p))
            std::cout << "File size: " << fs::file_size(p) << " bytes\n";
        else if (fs::is_directory(p))
            std::cout << p << " is a directory\n";
    }
    else {
        std::cout << p << " does not exist\n";
    }
}




#include <boost/filesystem.hpp>
#include <iostream>
namespace fs = boost::filesystem;
int main() {
    fs::path dir(".");
    if (fs::exists(dir) && fs::is_directory(dir)) {
        std::cout << "Files in " << dir << ":\n";
        for (auto& entry : fs::directory_iterator(dir)) {
            std::cout << " - " << entry.path().filename().string() << "\n";
        }
    }
}





#include <boost/filesystem.hpp>
#include <iostream>
namespace fs = boost::filesystem;
int main() {
    fs::path dir("test_dir");
    if (!fs::exists(dir)) {
        fs::create_directory(dir);
        std::cout << "Directory created: " << dir << "\n";
    }
    fs::remove(dir);
    std::cout << "Directory removed: " << dir << "\n";
}




#include <boost/filesystem.hpp>
#include <iostream>
namespace fs = boost::filesystem;
int main() {
    fs::path dir(".");
    std::cout << "Recursive list of " << dir << ":\n";
    for (auto& entry : fs::recursive_directory_iterator(dir)) {
        std::cout << entry.path() << "\n";
    }
}










#include <iostream>
#include <filesystem>
#include <fstream>

int main()
{
    
    std::ofstream ofs;
    ofs.open(".\\Hello.txt");
    ofs << "this is some text in the new file\n";
    ofs.close();

    return 0;
}









#include <boost/asio.hpp>
#include <iostream>
using boost::asio::ip::tcp;
int main() {
    boost::asio::io_context io;
    tcp::resolver resolver(io);
    tcp::resolver::results_type endpoints = resolver.resolve("example.com", "80");
    tcp::socket socket(io);
    boost::asio::connect(socket, endpoints);
    std::string request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
    boost::asio::write(socket, boost::asio::buffer(request));
    char ourbuffer[1024];
    size_t len = socket.read_some(boost::asio::buffer(ourbuffer));
    std::cout.write(ourbuffer, len);
    return 0;
}





#include <boost/regex.hpp>
#include <iostream>
#include <string>
int main() {
    std::string text = "My email is example@test.com and backup is user@domain.org";
    boost::regex pattern(R"((\w+)@(\w+)\.(\w+))");  // username@domain.tld
    boost::smatch matches;
    std::string::const_iterator start = text.begin();
    std::string::const_iterator end = text.end();
    while (boost::regex_search(start, end, matches, pattern)) {
        std::cout << "Full match: " << matches[0] << "\n";
        std::cout << "  Username: " << matches[1] << "\n";
        std::cout << "  Domain:   " << matches[2] << "\n";
        std::cout << "  TLD:      " << matches[3] << "\n\n";
        start = matches[0].second;  // move past this match
    }
    return 0;
}





//#include <boost/regex.hpp>
#include <iostream>
#include <string>
#include<regex>
//using namespace boost;
using namespace std;

int main() {
    std::string text = "Boost123 Regex456 Example789";
    regex expr("\\d+");   // Match digits
    smatch match;
    while (regex_search(text, match, expr)) {
        std::cout << "Found: " << match[0] << "\n";
        text = match.suffix();  // Move to next
    }
}







#include <boost/bind.hpp>
#include <iostream>
int add(int a, int b) {
    return a + b;
}
struct Printer {
    void print(int x) { std::cout << "Value: " << x << std::endl; }
};
int main() {
    Printer p;
    // Bind member function to object
    auto f1 = boost::bind(&Printer::print, &p, _1);
    f1(100);  // Output: Value: 100

    // Bind first argument as 10
    auto f2 = boost::bind(add, 10, _1);  // _1 is a placeholder
    std::cout << f2(20) << std::endl;    // 10 + 20 = 30
}





#include <boost/bind/bind.hpp>
#include <iostream>
using namespace boost::placeholders; // for _1, _2, ...
int add3(int a, int b, int c) {
    return a + b + c;
}
int main() {
    // Fix the first argument to 5, let the next two be placeholders
    auto f1 = boost::bind(add3, 5, _1, _2);
    std::cout << "f1(10, 20) = " << f1(10, 20) << "\n"; // 5 + 10 + 20 = 35

    // Fix the first and second arguments, leave the third dynamic
    auto f2 = boost::bind(add3, 100, 200, _1);
    std::cout << "f2(50) = " << f2(50) << "\n"; // 100 + 200 + 50 = 350

    // Swap arguments using placeholders
    auto f3 = boost::bind(add3, _2, _1, 0);
    std::cout << "f3(7, 3) = " << f3(7, 3) << "\n"; // 3 + 7 + 0 = 10

    return 0;
}





#include <iostream>
#include <vector>
#include <algorithm>
#include <boost/lambda/lambda.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/lambda/if.hpp>   // <- important for if_then_else_return

int main() {
    using namespace boost::lambda;

    std::vector<int> v = { 1, 2, 3, 4, 5 };

    // Example 1: Two-parameter lambda (sum two numbers)
    auto sum = _1 + _2;
    std::cout << "Sum(10, 20) = " << sum(10, 20) << "\n";

    // Example 2: Multiply with two arguments
    auto multiply = _1 * _2;
    std::cout << "Multiply(5, 6) = " << multiply(5, 6) << "\n";

    // Example 3: Binding multiple arguments in STL algorithm
    std::cout << "Vector elements + 100:\n";
    std::for_each(v.begin(), v.end(),
        std::cout << (_1 + 100) << " "    // _1 refers to current element
    );
    std::cout << "\n";

    // Example 4: Compare two numbers
    auto greater = _1 > _2;
    std::cout << "Is (15 > 10)? " << (greater(15, 10) ? "Yes" : "No") << "\n";

    // Example 5: Ternary-like expression (multiple parameters used)
    auto choose = if_then_else_return(_1 > _2, _1, _2);
    std::cout << "Max(7, 9) = " << choose(7, 9) << "\n";

    return 0;
}





