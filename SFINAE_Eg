#include <iostream>
#include <type_traits>

template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is integral.\n";
}

template<typename T>
typename std::enable_if<!std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is NOT integral.\n";
}

int main() {
    print(42);     // integral
    print(3.14);   // NOT integral
    print("Abc");
}







#include <iostream>
#include <typeinfo>

int main() {
    int x = 10;
    double y = 3.14;

    decltype(x) a = 5;     // 'a' is of type int
    decltype(y) b = 2.5;   // 'b' is of type double

    std::cout << typeid(a).name() << "\n"; // Usually prints "i" (int)
    std::cout << typeid(b).name() << "\n"; // Usually prints "d" (double)
}






#include <iostream>
#include <typeinfo>
#include <string>

int foo() { return 42; } // Example function

// Generic template function using decltype to deduce return type
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    

    // 1️. With Expressions
    int i = 0;
    decltype(i + 2.5) result = i + 2.5; // double
    std::cout << "decltype(i + 2.5) -> " << typeid(result).name()
        << " value: " << result << "\n";

    // 2️. With Functions
    decltype(foo()) val = foo(); // int
    std::cout << "decltype(foo()) -> " << typeid(val).name()
        << " value: " << val << "\n";

    // 3️. Value Categories
    int x = 5;
    int& ref = x;

    decltype(x)   a = x; // int
    decltype(ref) b = x; // int& (reference preserved)
    decltype((x)) c = x; // int& (expression, yields reference)

    a = 10;
    b = 20; // changes x
    c = 30; // also changes x

    std::cout << "decltype(x) a = " << a << "\n";
    std::cout << "decltype(ref) b = " << b << "\n";
    std::cout << "decltype((x)) c = " << c << "\n";
    std::cout << "x after b and c changes: " << x << "\n";

    // 4️. Common Use Case - Templates
    auto sum1 = add(2, 3.5);         // deduced double
    auto sum2 = add(std::string("Hello, "), std::string("World!")); // deduced std::string

    std::cout << "add(2, 3.5) -> " << sum1 << " (" << typeid(sum1).name() << ")\n";
    std::cout << "add(strings) -> " << sum2 << " (" << typeid(sum2).name() << ")\n";

    return 0;
}









#include <iostream>
#include <type_traits>

template <typename T>
void printTypeInfo(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << value << " is integral.\n";
    }
    else if constexpr (std::is_floating_point_v<T>) {
        std::cout << value << " is floating point.\n";
    }
    else {
        std::cout << "Unknown type.\n";
    }
}
int main() {
    printTypeInfo(42);     // 42 is integral.
    printTypeInfo(3.14);   // 3.14 is floating point.
    printTypeInfo("Hi");   // Unknown type.
}






#include <concepts>
#include <iostream>
//template<typename T>  //without concepts
//T add(T a, T b) {
//    return a + b; // error only happens if T doesn't support +
//}
template<std::integral T> // concept: only integers allowed
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout << add(2, 3) << "\n";   // works
     //std::cout << add(2.5, 3.5) << "\n"; // compile-time error: doesn't satisfy integral
}





#include <iostream>
#include <vector>
using namespace std;

int main() {
    auto x = 10;         // deduced as int
    auto y = 3.14;       // deduced as double
    auto z = "Hello";    // deduced as const char*

    vector<int> v = {1, 2, 3, 4, 5};

    // use auto in loops
    for (auto i : v) {
        cout << i << " ";  // i deduced as int
    }

    return 0;
}














