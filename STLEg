#include<iostream>
#include <vector>
using namespace std;
int main() {
    vector <int> vNums;
    int i;
    for (i=1; i<=5; ++i )
        vNums.push_back(i); //append elements
    for (i=0; i< vNums.size(); i++ )
        cout << vNums[ i ] << ' ';
    cout<<endl;
    vNums.erase(vNums.begin() );//remove first element
   cout<<endl;
    vNums.pop_back();//remove last element
   for (i = 0; i< vNums.size(); i++)
        cout << vNums[ i ] << ' ';
   cout<<endl;
   return 0;
}


//Create a vector of Employees
//Insert 5 employees from user input


#include <iostream>
#include <deque>
using namespace std;
int main(){
    deque <int> deNums;
    int i;
    for (i = 1; i<=5; ++i )
        deNums.push_back(i); // append elements
    for (i = 2; i <= 5; i++)
        deNums.push_front(i); // insert at front
    for (i = 0; i < deNums.size(); i++)
        cout << deNums[i] << ' ';
    cout<<endl;
    return 0;
}




#include <iostream>
#include <list>
using namespace std;
void PrintList(list<int> nums) {
    while(!nums.empty()) {
        cout << nums.front() << ' '; // display 1st element
        nums.pop_front(); }// remove 1st element
    cout << endl;
}
int main(){
    list<int> nums;
    for (int i=1; i<=5; ++i)
        nums.push_back(i);
    PrintList(nums); // 1 2 3 4 5
    nums.reverse(); PrintList(nums); // 5 4 3 2 1
    nums.sort(); PrintList(nums); // 1 2 3 4 5
    return 0;
}





// Employees list : id, name, Sal
// sum of all expenses company (sal's sumation) + 10000





// pair::pair example
#include <utility>      // std::pair, std::make_pair
#include <string>       // std::string
#include <iostream>     // std::cout

int main () {
  std::pair <std::string,double> product1;                     // default constructor
  std::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
  std::pair <std::string,double> product3 (product2);          // copy constructor

  product1 = std::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)

  product2.first = "shoes";                  // the type of first is string
  product2.second = 39.90;                   // the type of second is double

  std::cout << "The price of " << product1.first << " is $" << product1.second << '\n';
  std::cout << "The price of " << product2.first << " is $" << product2.second << '\n';
  std::cout << "The price of " << product3.first << " is $" << product3.second << '\n';
  return 0;
}






#include <iostream>
#include <set>
int main() {
	std::set<int> mymultiset;
	std::set<int>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++) mymultiset.insert(i * 10);  // 10 20 30 40 50
	int myints[] = { 5,10,15 };
	mymultiset.insert(myints, myints + 3);
	std::cout << "myset contains:";
	for (it = mymultiset.begin(); it != mymultiset.end(); ++it)
		std::cout << ' ' << *it;
	std::cout << '\n';
	return 0;
}







#include <iostream>
#include <set>
using namespace std;
class Emp {
public:
	int id;
	Emp(int x) { id = x; }
	Emp() {}
	bool operator<(const Emp& other) const {
		return this->id < other.id;  // only compare id
	}

};
int main() {
	std::set<Emp> Emps;
	std::set<Emp>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++)
	{
		int j = i * 10;
		Emps.insert(Emp(j));  // 10 20 30 40 50
	}
	Emps.insert(Emp(35));
	Emps.insert(Emp(30));
	std::cout << "\nMyset contains:\n";
	for (it = Emps.begin(); it != Emps.end(); ++it)
		std::cout << ' ' << it->id;
	std::cout << '\n';
	return 0;
}





#include <iostream>
#include <set>
#include <string>

class Employee {
    int id;
    std::string name;

public:
    Employee(int id, std::string name) : id(id), name(std::move(name)) {}

    int getId() const { return id; }
    std::string getName() const { return name; }

    // operator< defined inside class
    bool operator<(const Employee& other) const {
        return this->id < other.id;  // only compare id
    }

    friend std::ostream& operator<<(std::ostream& os, const Employee& e) {
        return os << "Employee{id=" << e.id << ", name=" << e.name << "}";
    }
};

int main() {
    std::set<Employee> employees;

    employees.emplace(1, "Alice");
    employees.emplace(2, "Bob");
    employees.emplace(1, "Charlie"); // ignored (duplicate id)

    for (const auto& e : employees) {
        std::cout << e << "\n";
    }
}





#include <iostream>
#include <set>
#include <string>

class Employee {
    int id;
    std::string name;

public:
    Employee(int id, std::string name) : id(id), name(std::move(name)) {}

    int getId() const { return id; }
    std::string getName() const { return name; }

    // For printing
    friend std::ostream& operator<<(std::ostream& os, const Employee& e) {
        return os << "Employee{id=" << e.id << ", name=" << e.name << "}";
    }
};

// Custom comparator: compare only by id
struct EmployeeComparator {
    bool operator()(const Employee& lhs, const Employee& rhs) const {
        return lhs.getId() < rhs.getId();   // uniqueness check is based only on id
    }
};

int main() {
    std::set<Employee, EmployeeComparator> employees;

    employees.emplace(1, "Alice");
    employees.emplace(2, "Bob");
    employees.emplace(1, "Charlie"); // duplicate id -> won't be inserted

    for (const auto& e : employees) {
        std::cout << e << "\n";
    }
}














